#!/usr/bin/env python3
"""Places v1.1 by Lars Ole Pontoppidan. 

CLI tool for managing folder bookmarks and places in Linux desktop environments. 

https://github.com/larspontoppidan/places-cli
"""

Usage = """Usage:
  places list                    List all bookmarks
  places add <TITLE> <PATH>      Add bookmark at PATH with the given TITLE
  places add <PATH>              Add bookmark at PATH using the PATH folder name as title
  places add <FILE>              Add bookmark at the folder of FILE using FILE name as title
  places remove <TITLE>|<PATH>   Remove bookmark referring to TITLE or PATH
"""

# ----

import sys
import os
from urllib.parse import quote, unquote, urlparse
from lxml import etree

def get_places() -> list["PlacesBase"]:
    # This list may be modified to tailor the script:
    return [
        KDEPlaces(),
        GtkPlaces("3.0"),
        GtkPlaces("4.0")
    ]

# ---- Utils


class NotSupportedException(Exception):
    pass

class UsageException(Exception):
    pass

def decode_file_uri(uri: str) -> str:
    """Convert file:// URI to plain filesystem path."""
    if not uri.startswith("file://"):
        return uri
    path = urlparse(uri).path
    return unquote(path)

def encode_file_uri(path: str) -> str:
    """Convert filesystem path to file:// URI, with proper percent encoding."""
    return "file://" + quote(path)

# ---- Places implementations

class PlacesBase:
    def __init__(self, name:str):
        self.name = name
    def __str__(self):
        return self.name
    def getFileName(self) -> str:
        pass # To implement in subclass
    def load(self):        
        pass # To implement in subclass
    def save(self):
        pass # To implement in subclass
    def findTitle(self, title: str) -> str | None:
        pass # To implement in subclass
    def findPath(self, path: str) -> str | None:
        pass # To implement in subclass
    def add(self, title: str, path: str):
        pass # To implement in subclass
    def remove(self, title: str):
        pass # To implement in subclass
    def list(self):
        pass # To implement in subclass

class KDEPlaces(PlacesBase):
    """ KDE Places implementation.

    KDE stores its file manager bookmarks in an XML file:
      ~/.local/share/user-places.xbel

    Each <bookmark> element has the form:
      <bookmark href="file://PATH" title="TITLE"/>
    """

    def __init__(self):
        super().__init__("KDE user places")
        self.xbelPath = os.path.expanduser("~/.local/share/user-places.xbel")

    def getFileName(self) -> str:
        return self.xbelPath

    def load(self):
        if not os.path.exists(self.xbelPath):
            raise NotSupportedException()
        parser = etree.XMLParser(remove_blank_text=False)
        self.tree = etree.parse(self.xbelPath, parser)
        self.root = self.tree.getroot()

    def save(self):
        self.tree.write(self.xbelPath, pretty_print=True, xml_declaration=True, encoding="utf-8")

    def findTitle(self, title: str) -> str | None:
        for bm in self.root.findall(".//bookmark"):
            href = bm.get("href", "")
            if href.startswith("file:") and bm.findtext("title") == title:
                return decode_file_uri(href)
        return None

    def findPath(self, path: str) -> str | None:
        for bm in self.root.findall(".//bookmark"):
            href = bm.get("href", "")
            if href.startswith("file:") and decode_file_uri(href) == path:
                return bm.findtext("title")
        return None
    
    def add(self, title: str, path: str):
        href = encode_file_uri(path)
        bm = etree.Element("bookmark", href=href)
        title_el = etree.SubElement(bm, "title")
        title_el.text = title
        self.root.append(bm)

    def remove(self, title: str) -> bool:
        removed = False
        for bm in self.root.findall(".//bookmark"):
            href = bm.get("href", "")
            if href.startswith("file:") and bm.findtext("title") == title:
                self.root.remove(bm)
                removed = True
                break
        return removed

    def list(self):
        bookmarks = self.root.findall(".//bookmark")
        for bm in bookmarks:
            href = bm.get("href", "")
            if href.startswith("file:"):
                path = decode_file_uri(href)
                title_el = bm.find("title")
                title = title_el.text if title_el is not None else "(no title)"
                print(f"  %-20s %s" % (title, path))


class GtkPlaces(PlacesBase):
    """
    GTK places implementation (Gnome, Xfce, etc.)

    GTK stores its file manager bookmarks in a plain text file:
      ~/.config/gtk-<version>/bookmarks

    Each non-empty line has the form:
      URI[ SPACE LABEL]
    """

    def __init__(self, gtk_version: str):
        super().__init__(f"GTK-{gtk_version} bookmarks")
        self.bookmarksFolder = os.path.expanduser(f"~/.config/gtk-{gtk_version}")
        self.bookmarksFile = os.path.join(self.bookmarksFolder, "bookmarks")
        self.entries: list[tuple[str, str]] = []

    def getFileName(self) -> str:
        return self.bookmarksFile

    def load(self):
        # If the folder doesn't exist, gtk-<version> is not supported
        if not os.path.exists(self.bookmarksFolder):
            raise NotSupportedException()

        # If the file doesn't exist, create it
        if not os.path.exists(self.bookmarksFile):
            # Do equivalent of touch
            open(self.bookmarksFile, "w").close()

        self.entries = []
        with open(self.bookmarksFile, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                # Format: URI[ SPACE LABEL]
                if " " in line:
                    uri, label = line.split(" ", 1)
                else:
                    uri, label = line, ""
                self.entries.append((uri, label))

    def save(self):
        with open(self.bookmarksFile, "w", encoding="utf-8") as f:
            for uri, label in self.entries:
                if label:
                    f.write(f"{uri} {label}\n")
                else:
                    f.write(f"{uri}\n")

    def findTitle(self, title: str) -> str | None:
        for uri, label in self.entries:
            if label == title:
                return decode_file_uri(uri)
        return None

    def findPath(self, path: str) -> str | None:
        for uri, label in self.entries:
            if decode_file_uri(uri) == path:
                return label
        return None

    def add(self, title: str, path: str):
        # Store as file:// URI for local paths, matching GNOME's expectations.
        uri = encode_file_uri(path)
        self.entries.append((uri, title))

    def remove(self, title: str) -> bool:
        removed = False
        new_entries: list[tuple[str, str]] = []
        for uri, label in self.entries:
            if not removed and label == title:
                removed = True
                continue
            new_entries.append((uri, label))
        self.entries = new_entries
        return removed

    def list(self):
        if not self.entries:
            print("  (empty)")
        else:
            for uri, label in self.entries:
                path = decode_file_uri(uri)
                title = label if label else "(no title)"
                print(f"  %-20s %s" % (title, path))

# ----

def process(places: PlacesBase, cmd: str, arg1: str, arg2: str):
    if cmd == "list":
        places.load()
        print(f"{str(places)}: ({places.getFileName()})")
        places.list()
        print()
    elif cmd == "add":
        places.load()
        if places.findTitle(arg1):
            print(f"'{arg1}' already exists in {str(places)}")
            return
        places.add(arg1, arg2)
        places.save()
        print(f"Added: '{arg1}' at: '{arg2}' to {str(places)}")
    elif cmd == "remove":
        places.load()
        path = places.findTitle(arg1)
        if path:
            # User specified a title
            places.remove(arg1)
            places.save()
            print(f"Removed: '{arg1}' at: '{path}' from {str(places)}")
        else:
            # Try to search for a path
            path = os.path.abspath(os.path.expanduser(arg1))
            title = places.findPath(path)
            if title:
                places.remove(title)
                places.save()
                print(f"Removed: '{title}' at: '{path}' from {str(places)}")
            else:
                print(f"Couldn't find title '{arg1}' or path '{path}' to remove in {str(places)}")
    else:
        raise UsageException()

def processArgs(args: list[str]) -> tuple:
    # Returns cmd, title, path
    cmd = args[0]
    if cmd == "list" and len(args) == 1:
        return cmd, None, None
    elif cmd == "add":
        if len(args) == 3:
            # User specified both title and path
            path = os.path.abspath(os.path.expanduser(args[2]))
            title = args[1]
            if not os.path.isdir(path):
                raise ValueError("Path does not exist: " + path)
        elif len(args) == 2:
            if os.path.isdir(args[1]):
                # User specified a path, use the folder name as title
                path = os.path.abspath(os.path.expanduser(args[1]))
                title = os.path.basename(path)
            elif os.path.isfile(args[1]):
                # User specified a file, use the file name as title and the parent folder as path
                path = os.path.abspath(os.path.expanduser(os.path.dirname(args[1])))
                title = os.path.basename(args[1])
            else:
                raise ValueError("Path or file does not exist: " + args[1])
        else:
            raise UsageException("Invalid number of arguments")
        return cmd, title, path
    elif cmd == "remove" and len(args) == 2:
        return cmd, args[1], None
    else:
        raise UsageException("Invalid command or arguments")


if __name__ == "__main__":
    if len(sys.argv) == 1:
        print(__doc__)
        print(Usage)
        print("Enabled environments:")
        for places in get_places():
            print(f"  {str(places)}")
        print()
    else:
        try:
            cmd, arg1, arg2 = processArgs(sys.argv[1:])
            for places in get_places():
                try:
                    process(places, cmd, arg1, arg2)
                except NotSupportedException as e:
                    print(f"{str(places)} is not supported")
                except Exception as e:
                    print(f"Command failed for {str(places)}: {str(e)}")
        except ValueError as e:
            print(str(e)+"\n")
        except UsageException as e:
            print(str(e)+"\n")
            print(Usage)

